import json
import os
from typing import Dict, Any

class NotebookGenerator:
    """
    Generates a Jupyter Notebook for QFoundry design based on specifications.
    """
    full_specifications = {}
    layout_graph = {}

    def __init__(self):
        pass

    def create_notebook(self, specs: Dict[str, Any], output_path: str):
        """
        Create a .ipynb file with the given specifications.
        
        Args:
            specs: Dictionary of specifications from the Agent.
            output_path: Path to save the generated notebook.
        """
        
        # Extract parameters
        design_name = specs.get("design_name", "Generated Design")
        description = specs.get("description", "AI Generated Design")
        qubit_count = specs.get("qubit_count", 16)
        families = specs.get("qubit_families", [])
        topology = specs.get("topology_type", "square")
        grid_dims = specs.get("grid_dimensions", [4, 4])
        
        # Construct the notebook content
        cells = []
        
        # Cell 1: Header
        cells.append({
            "cell_type": "markdown",
            "metadata": {},
            "source": [
                f"# {design_name}\n",
                "\n",
                f"**Description:** {description}\n",
                "\n",
                "Generated by QFoundry AI Agent."
            ]
        })
        
        # Cell 2: Imports
        cells.append({
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "%matplotlib inline\n",
                "import sys, os\n",
                "import numpy as np\n",
                "import pandas as pd\n",
                "import rustworkx as rx\n",
                "from rustworkx.visualization import mpl_draw\n",
                "from matplotlib import pyplot as plt\n",
                "\n",
                "from qfoundry import cpw_resonator, cpw\n",
                "from qfoundry.utils import sc_metal\n",
                "from qfoundry.qubits import transmon, tunable_transmon\n",
                "from qfoundry.PDK import PDK\n",
                "from qfoundry.topology import LatticeGenerator\n",
                "from qfoundry.coloring import RelaxedColoring\n",
                "\n",
                "pdk = PDK()\n",
                "print(f\"Loaded PDK: {pdk}\")"
            ]
        })
        
        # Cell 3: Design Parameters
        # Convert families list to python code
        families_code = "qubit_families = [\n"
        for fam in families:
            families_code += f"    {fam},\n"
        families_code += "]\n"
        
        cells.append({
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Design Specifications\n",
                f"design_name = '{design_name}'\n",
                f"n_qubits = {qubit_count}\n",
                f"topology_type = '{topology}'\n",
                f"grid_rows = {grid_dims[0]}\n",
                f"grid_cols = {grid_dims[1]}\n",
                f"coloring_strategy_name = '{specs.get('coloring_strategy', 'RelaxedColoring')}'\n",
                "\n",
                "# Qubit Families Parameters\n",
                families_code,
                "\n",
                "# Guidelines\n",
                "guidelines = " + json.dumps(specs.get("design_guidelines", []), indent=4)
            ]
        })
        
        # Cell 4: Topology Generation
        cells.append({
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Generate Topology\n",
                "lattice_gen = LatticeGenerator()\n",
                "\n",
                "if topology_type == 'square':\n",
                "    graph, info = lattice_gen.generate_square_lattice(grid_rows, grid_cols)\n",
                "elif topology_type == 'hexagonal':\n",
                "    graph, info = lattice_gen.generate_hexagonal_lattice(grid_rows, grid_cols)\n",
                "else:\n",
                "    # Fallback to square\n",
                "    print(f\"Warning: Unknown topology {topology_type}, defaulting to square.\")\n",
                "    graph, info = lattice_gen.generate_square_lattice(grid_rows, grid_cols)\n",
                "\n",
                "print(f\"Generated {info.lattice_type} lattice with {info.num_nodes} nodes and {info.num_edges} edges.\")\n",
                "\n",
                "# Visualize\n",
                "plt.figure(figsize=(8, 8))\n",
                "fig = rx.visualization.mpl_draw(graph, pos=info.node_positions, with_labels=True)\n",
                "plt.title(f\"{design_name} Topology\")\n",
                "plt.show()"
            ]
        })
        
        # Cell 5: Frequency Allocation (Placeholder logic)
        cells.append({
            "cell_type": "code",
            "execution_count": None,
            "metadata": {},
            "outputs": [],
            "source": [
                "# Assign Frequencies based on Families using Coloring Strategy\n",
                "\n",
                "# Prepare families dict for coloring function\n",
                "available_families = {}\n",
                "colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b'] # matplotlib default cycle\n",
                "for i, fam in enumerate(qubit_families):\n",
                "    available_families[fam['family_id']] = {\n",
                "        'color': colors[i % len(colors)],\n",
                "        'frequency': fam['frequency_mean']\n",
                "    }\n",
                "\n",
                "# Select Strategy\n",
                "if coloring_strategy_name == 'RelaxedColoring':\n",
                "    strategy = RelaxedColoring(max_same_color_neighbors=2)\n",
                "    color_map = strategy(graph)\n",
                "else:\n",
                "    # Use rustworkx built-in greedy coloring\n",
                "    color_map = rx.graph_greedy_color(graph)\n",
                "\n",
                "print(f\"Applying coloring strategy: {coloring_strategy_name}\")\n",
                "\n",
                "node_frequencies = {}\n",
                "num_families = len(qubit_families)\n",
                "\n",
                "for node in graph.node_indices():\n",
                "    color_idx = color_map[node]\n",
                "    family_idx = color_idx % num_families\n",
                "    fam_spec = qubit_families[family_idx]\n",
                "    node_frequencies[node] = fam_spec['frequency_mean']\n",
                "    \n",
                "print(\"Assigned Frequencies:\")\n",
                "print(node_frequencies)\n",
                "\n",
                "# Visualize with Frequencies\n",
                "plt.figure(figsize=(10, 8))\n",
                "node_colors = [node_frequencies[n] for n in graph.node_indices()]\n",
                "rx.visualization.mpl_draw(\n",
                "    graph, \n",
                "    pos=info.node_positions, \n",
                "    with_labels=True, \n",
                "    node_color=node_colors, \n",
                "    cmap='viridis',\n",
                "    node_size=500\n",
                ")\n",
                "plt.title(f\"{design_name} - Frequency Allocation ({coloring_strategy_name})\")\n",
                "plt.colorbar(plt.cm.ScalarMappable(cmap='viridis', norm=plt.Normalize(min(node_colors), max(node_colors))), label='Frequency (Hz)')\n",
                "plt.show()\n",
                "\n",
                "# Print detailed family info including drive/readout\n",
                "print(\"\\nDetailed Qubit Family Specifications:\")\n",
                "for fam in qubit_families:\n",
                "    print(f\"Family {fam['family_id']}:\")\n",
                "    print(f\"  Type: {fam.get('qubit_type', 'N/A')}\")\n",
                "    print(f\"  Freq: {fam['frequency_mean']/1e9:.2f} GHz\")\n",
                "    if fam.get('drive_line'):\n",
                "        print(f\"  Drive Line: Yes (Coupling: {fam.get('drive_coupling', 0)/1e6:.1f} MHz)\")\n",
                "    else:\n",
                "        print(f\"  Drive Line: No\")\n",
                "        \n",
                "    if fam.get('readout_resonator'):\n",
                "        print(f\"  Readout Resonator: Yes (Coupling: {fam.get('resonator_coupling', 0)/1e6:.1f} MHz)\")\n",
                "    else:\n",
                "        print(f\"  Readout Resonator: No\")"
            ]
        })

        notebook_json = {
            "cells": cells,
            "metadata": {
                "kernelspec": {
                    "display_name": "Python 3",
                    "language": "python",
                    "name": "python3"
                },
                "language_info": {
                    "codemirror_mode": {
                        "name": "ipython",
                        "version": 3
                    },
                    "file_extension": ".py",
                    "mimetype": "text/x-python",
                    "name": "python",
                    "nbconvert_exporter": "python",
                    "pygments_lexer": "ipython3",
                    "version": "3.8.5"
                }
            },
            "nbformat": 4,
            "nbformat_minor": 4
        }
        
        # Ensure directory exists
        os.makedirs(os.path.dirname(os.path.abspath(output_path)), exist_ok=True)
        
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(notebook_json, f, indent=1)
        
        print(f"Notebook generated at: {output_path}")
